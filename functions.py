import logfire
import dotenv
import os
from pydantic_ai.agent import Agent
from pydantic_ai.models.groq import GroqModel
from pydantic_ai.providers.groq import GroqProvider
from pydantic import BaseModel, Field
from typing import List, Dict, Any, Tuple, Optional
import streamlit as st

from prompts import customer_support_prompt, evaluator_prompt, rewriter_prompt
import json
from datetime import datetime
from pathlib import Path


class EvaluatorOutput(BaseModel):
    improvement_instr: list[str] = Field("Improvement instructions from the agent")
    score: int = Field("Score between 1 to 100 about how well the agent has performed according to the metrics")


class RewriterOutput(BaseModel):
    new_prompt: str = Field("updated system prompt")
    improvements: list[str] = Field("What improvements where made.")


def initialize_environment() -> Tuple[str, str]:
    """
    Initializes environment variables by loading them from a .env file
    and returns the necessary API keys. It also configures Logfire for monitoring.

    Returns:
        Tuple[str, str]: A tuple containing the GROQ API key and Logfire token.
    """
    dotenv.load_dotenv()
    groq_key = os.getenv("GROQ_KEY")
    logfire_token = os.getenv("LOGFIRE_TOKEN")

    if not groq_key:
        groq_key = st.secrets['GROQ_KEY']
        logfire_token = st.secrets['LOGFIRE_TOKEN']
    
    if logfire_token:
        logfire.configure(token=logfire_token)
        logfire.instrument_pydantic_ai()
    
    return groq_key, logfire_token


def create_model(groq_key: str) -> GroqModel:
    """
    Creates and returns a GroqModel instance for the AI agent.

    Args:
        groq_key (str): The API key for the Groq service.

    Returns:
        GroqModel: An instance of the GroqModel.
    """
    return GroqModel(
        'qwen/qwen3-32b', provider=GroqProvider(api_key=groq_key)
    )


def create_agents(model: GroqModel, custom_criteria: str = "") -> Tuple[Agent, Agent]:
    """
    Creates and returns the evaluator and rewriter agents.

    Args:
        model (GroqModel): The language model to be used by the agents.
        custom_criteria (str, optional): Additional criteria for the evaluator agent. 
                                         Defaults to "".

    Returns:
        Tuple[Agent, Agent]: A tuple containing the evaluator and rewriter agents.
    """
    evaluator_system_prompt = evaluator_prompt
    if custom_criteria:
        evaluator_system_prompt += f"\n\nEvaluation Criteria:\n{custom_criteria}"

    evaluator_agent = Agent(
        system_prompt=evaluator_system_prompt,
        model=model,
        output_type=EvaluatorOutput
    )

    rewriter_agent = Agent(
        system_prompt=rewriter_prompt,
        output_type=RewriterOutput,
        model=model
    )
    
    return evaluator_agent, rewriter_agent


def create_customer_support_agent(model: GroqModel, system_prompt: str) -> Agent:
    """
    Creates a customer support agent with a given system prompt.

    Args:
        model (GroqModel): The language model for the agent.
        system_prompt (str): The system prompt that defines the agent's behavior.

    Returns:
        Agent: An instance of the customer support agent.
    """
    return Agent(
        model=model,
        system_prompt=system_prompt,
        output_type=str,
    )


def initialize_interaction_log() -> Path:
    """
    Initializes the interaction log file by creating it with an empty JSON array.

    Returns:
        Path: The path to the newly created log file.
    """
    log_file = Path("interactions.json")
    log_file.write_text("[]", encoding="utf-8")
    return log_file


def log_interaction(log_file: Path, user_input: str, agent_output: str) -> None:
    """
    Logs a user interaction to the specified JSON file.

    Args:
        log_file (Path): The path to the log file.
        user_input (str): The input provided by the user.
        agent_output (str): The output generated by the agent.
    """
    try:
        data = json.loads(log_file.read_text())
    except Exception:
        data = []

    data.append({
        "user_input": user_input,
        "agent_output": agent_output,
    })

    log_file.write_text(json.dumps(data, ensure_ascii=False, indent=2))


def evaluate_performance(evaluator_agent: Agent, log_content: str) -> EvaluatorOutput:
    """
    Evaluates the agent's performance based on the conversation log.

    Args:
        evaluator_agent (Agent): The agent responsible for evaluation.
        log_content (str): The content of the conversation log.

    Returns:
        EvaluatorOutput: An object containing improvement instructions and a score.
    """
    response = evaluator_agent.run_sync(log_content)
    return response.output


def rewrite_prompt(rewriter_agent: Agent, old_prompt: str, improvement_instructions: List[str]) -> RewriterOutput:
    """
    Rewrites the system prompt based on improvement instructions.

    Args:
        rewriter_agent (Agent): The agent responsible for rewriting the prompt.
        old_prompt (str): The original system prompt.
        improvement_instructions (List[str]): A list of instructions for improvement.

    Returns:
        RewriterOutput: An object containing the new prompt and a list of improvements.
    """
    prompt_text = f"""
    old_prompt: {old_prompt} \n\n
    improvement_instructions: {improvement_instructions}
    """
    response = rewriter_agent.run_sync(prompt_text)
    return response.output


def save_new_prompt(new_prompt: str, improvements: List[str]) -> None:
    """
    Saves the new prompt and its improvements to a JSON file.

    Args:
        new_prompt (str): The newly generated system prompt.
        improvements (List[str]): The list of improvements made.
    """
    entry = {
        "new_prompt": new_prompt,
        "improvements": improvements,
    }

    json_file = Path("new_prompt.json")
    try:
        existing = json.loads(json_file.read_text(encoding="utf-8"))
        if not isinstance(existing, list):
            existing = [existing]
    except Exception:
        existing = []

    existing.append(entry)
    json_file.write_text(json.dumps(existing, ensure_ascii=False, indent=2), encoding="utf-8")


def run_customer_interaction(agent: Agent, user_queries: List[str]) -> List[Tuple[str, str]]:
    """
    Runs a series of customer interactions and logs them.

    Args:
        agent (Agent): The customer support agent.
        user_queries (List[str]): A list of queries from the user.

    Returns:
        List[Tuple[str, str]]: A list of tuples, each containing a user query and the agent's response.
    """
    interactions = []
    log_file = initialize_interaction_log()
    
    for query in user_queries:
        response = agent.run_sync(query)
        agent_output = response.output
        interactions.append((query, agent_output))
        log_interaction(log_file, query, agent_output)
    
    return interactions